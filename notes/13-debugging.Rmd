---
title: "Debugging"
output: html_document
---

### 1. Messages 

R has different levels of indication that something is not right, ranging from mere notification to fatal error. 

- `message`: A generic notification/diagnostic message produced by the `message()` function; execution of the function continues. 
- `warning`: An indication that something is wrong but not necessarily fatal; execution of the function continues. Warnings are generated by the `warning()` function.
- `error`: An indication that a fatal problem has occurred and execution of the function stops. Errors are produced by the `stop()` function.
- `condition`: A generic concept indicating that something unexpected has occurred; programmers can create their own custom conditions if they want. 


### 2. Debugging tools

The primary tools for debugging functions in R are

- `traceback()`: prints out the function call stack after an error occurs; does nothing if there's no error.
- `debug()`: flags a function for "debug" mode which allows you to step through execution of a function one line at a time.
- `browser()`: suspends the execution of a function wherever it is called and puts the function in debug mode
- `trace()`: allows you to insert debugging code into a function 
- `recover()`: allows you to modify the error behavior so that you can browse the function call stack.

These functions are interactive tools specifically designed to allow you to pick through a function. There's also the more blunt technique of inserting `print()` or `cat()` statements in the function. 

#### 2.1 `traceback()`

The `traceback()` function prints out the *function call statck* after an error has occurred. The function call stack is the sequence of functions that was called before the error occurred. 

The `traceback()` function must be called immediately after an error occurrs. Otherwise you lose the trace back.

```
> lm(y ~ x)
Error in eval(predvars, data, env) : object 'y' not found
> traceback()
7: eval(predvars, data, env)
6: eval(predvars, data, env)
5: model.frame.default(formula = y ~ x, drop.unused.levels = TRUE)
4: stats::model.frame(formula = y ~ x, drop.unused.levels = TRUE)
3: eval(mf, parent.frame())
2: eval(mf, parent.frame())
1: lm(y ~ x)
```

In the example above, you can see that the error did not get thrown until the 7th level of the function call stack, in which case `eval()` tried to evaluate the formula `y ~ x` and realized the object `y` did not exist. 

Looking at the traceback is useful for figuring out roughly where an error occurred but it's not useful for more detailed debugging. For that you might turn to the `debug()` function. 

#### 2.2 `debug()`

The `debug()` function initiates an interactive debugger (also known as the "browser" in R) for a function. With the debugger, you can step through an R function one expression at a time to pinpoinkt exactly where an error occurs. 

The `debug()` function takes a function as its first argument. 

```
> debug(lm) # Flag the lm() function for interactive debugging
```

Now every time you call the `lm()` function, it will launch the interactive debugger. 

The debugger calls the browser at the very top level of the function body. From there you can step through each expression in the body. There are a few special commands you can call in the browser: 

- `n`:  executes the current expression and moves to the next expression
- `c`:  continues execution of the function and does not stop until either an error or the function exits
- `Q`:  quits the browser

Here's an example of a brower session with the `lm()` function. 

```
Browse[2]> n
debug: ret.x <- x
Browse[2]> n
debug: ret.y <- y
Browse[2]> n
debug: cl <- match.call()
Browse[2]> n
debug: mf <- match.call(expand.dots = FALSE)
Browse[2]> n
debug: m <- match(c("formula", "data", "subset", "weights", "na.action", 
    "offset"), names(mf), 0L)
Browse[2]> n
debug: mf <- mf[c(1L, m)]
```

To turn the interactive debugger off, you need to call the `undebug()` function. 

#### 2.3 `recover()`

The `recover()` function can be used to modify the error behavior of R when an error occurs. 

With `recover()` you can tell R that when an error occurs, it should halt execution at the exact point at which the error occurred. That can give you the opportunity to poke around in the environment in which the error occurred. 

This can be useful to see if there are any R objects or data that have been corrupted or mistakenly modified. 

```
> options(error = recover)  ## Change default R error behavior
> read.csv("nosuchfile")
Error in file(file, "rt") : cannot open the connection
In addition: Warning message:
In file(file, "rt") :
  cannot open file 'nosuchfile': No such file or directory

Enter a frame number, or 0 to exit   

1: read.csv("nosuchfile")
2: read.table(file = file, header = header, sep = sep, quote = quote, dec = dec, fill = fill, comment.
3: file(file, "rt")

Selection: 
```

The `recover()` function will first print out the function call stack when an error occurrs. Then you can choose to jump around the call stack and investigate the problem. When you choose a frame number, you will be put in the browser (just like the interactive debugger triggered by `debug()`), and will have the ability to poke around. 








